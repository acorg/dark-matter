from collections import defaultdict
from dark.alignments import Alignment, ReadAlignments
from dark.hsp import HSP, LSP
from dark.sam.explain_sam_flags import explain_sam_flags
from dark.sam.hacks import checkSAMfile
from dark.score import HigherIsBetterScore
import re


class SAMRecordsReader(object):
    """
    Provide a method that yields alignment records from a SAM file.
    Store, check, and make accessible the alignment parameters.

    @param filename: A C{str} filename containing alignment records.
    @param application: The C{str} name of the alignment program used.
    @param scoreClass: A class to hold and compare scores (see scores.py).
        Default is C{HigherIsBetterScore}.
    @params match, mismatch, insert, delete: C{int}s used to create a score
        if Alignment score generated by aligner (AS) is not present in
        optional part of alignment section.
    """

    def __init__(self, filename, applicationParams=None,
                 scoreClass=HigherIsBetterScore, match=5, mismatch=-4,
                 insert=-1, delete=-1):
        self._filename = filename
        self._scoreClass = scoreClass
        self._appParams = applicationParams

        self.match = match
        self.mismatch = mismatch
        self.insert = insert
        self.delete = delete

        if scoreClass is HigherIsBetterScore:
            self._hspClass = HSP
        else:
            self._hspClass = LSP

        self._open(filename)
        self.application = applicationParams['application'].lower()

    def _autovivify(self, levels=1, final=dict):
        """
        From http://blogs.fluidinfo.com/terry/2012/05/26/autovivification-
        in-python-nested-defaultdicts-with-a-specific-final-type/
        """
        return (defaultdict(final) if levels < 2 else
                defaultdict(lambda: self._autovivify(levels - 1, final)))

    def _open(self, filename):
        """
        Open the input file. Set self._fp to point to it. Read the first
        line of parameters.

        @param filename: A C{str} filename containing alignment records.
        @raise ValueError: if the first line of the file isn't a valid SAM
            file.
        """
        if checkSAMfile(filename):
            self._fp = open(filename)
        else:
            raise ValueError('Invalid file type given: %s' % self._filename)

        line = self._fp.readline()
        if not line:
            raise ValueError('SAM file %r was empty.' % self._filename)

    def _convertCigarMD(self, cig, MD=None):
        """
        Calculates 'bitscore' from CIGAR and MD string if Alignment score
        generated by aligner (AS) is not present in optional part of
        alignment section.
        Bitscore scoring: =:5, X:-4, I:-1, D:-1, can be changed.

        @param cig: a C{dict} of numbers of CIGAR operations as present
            in the 6th field of a SAM file.
        @param MD: a C{str} MD string that may be present in the
            optional field of a SAM file.
        @return: a C{int} representing bitscore.
        """
        if cig['M'] > 0:
            seqLen = cig['M'] + cig['I'] + cig['S'] + cig['='] + cig['X']

            sepNumLetMD = re.findall('\d+|\D+', MD)
            # MD string does not account for insertions but does identify
            # matches and mismatches
            cigMD = {'matchMD': 0, 'misMD': 0, 'delMD': 0}
            for item in sepNumLetMD:
                if str.isdigit(item):
                    cigMD['matchMD'] += int(item)
                elif '^' in item:
                    # The letters following ^ in the MD are deletions from
                    # the subject
                    cigMD['delMD'] += len(item) - 1
                else:
                    cigMD['misMD'] += len(item)
            seqLenMD = cigMD['matchMD'] + cigMD['misMD']

            # Check that cigar and MD strings have been pased correctly
            assert seqLen - seqLenMD == cig['I'], ("seq lengths from MD "
                                                   "and cigar are not equal")
            assert cig['D'] == cigMD['delMD'], ("no. of deletions from MD "
                                                "and cigar are not equal")

            bit = (self.match * cigMD['matchMD'] +
                   self.mismatch * cigMD['misMD']
                   + self.insert * cig['I'] + self.delete * cigMD['delMD'])
            return bit
        else:
            bit = (self.match * cig['='] + self.mismatch * cig['X'] +
                   self.insert * cig['I'] + self.delete * cig['D'])
            return bit

    def _lineToHSP(self, line):
        """
        Take a line of a SAM file and convert it to an HSP.

        @param line: Line of a SAM file.
        @raise ValueError: If the query id in the SAM entry does not
            match the id of the read.
        @return: A L{dark.alignment.Alignment.HSP} instance.
        """
        # Parse elements of line which are needed.
        if line[0] not in '$@':
            line = line.strip().split()
            flag = line[1]
            refSeqName = line[2]
            pos = int(line[3])
            cigar = line[5]
            seq = line[9]
            optional = line[11:]

            if refSeqName != '*':
                optionalDict = {}
                for tag in optional:
                    key = tag.split(':')[0]
                    val = tag.split(':')[2]
                    optionalDict[key] = val

                # Parse cigar string
                cigarSplit = re.findall('\d+|\D+', cigar)
                # Initialise dict of cigar operations
                cig = {'M': 0, 'I': 0, 'D': 0, 'N': 0, 'S': 0, 'H': 0,
                       'P': 0, '=': 0, 'X': 0}
                # Check for valid cigar string.
                for item in cigarSplit:
                    if item.isalpha():
                        assert item in cig, ('Invalid CIGAR operation: %s'
                                             % item)
                    else:
                        assert item.isdigit(), ('Invalid item in CIGAR'
                                              'string: %s' % item)
                # Count the number of each cigar operation
                index = 0
                for element in xrange(0, len(cigarSplit), 2):
                    cig[cigarSplit[index + 1]] += int(cigarSplit[index])
                    index += 2

                try:
                    score = optionalDict['AS']

                # AS is most accurate score because it is: Alignment score
                # generated by aligner.
                # TODO Need to make sure if 'AS' is used as a score for one
                # read then it's used for all of the others - can't have mix
                # of AS and score from _convertCigarMD
                # But this function only takes a line.

                except KeyError:
                    if 'M' in cigar:
                        try:
                            MD = optionalDict['MD']
                        except KeyError:
                            raise ValueError("No optional tag MD. "
                                             "Run function findMD before "
                                             "proceeding")
                            # findMD is in dark/sam/hacks.py and uses samtools
                        else:
                            # MD is needed if the ambiguous 'M' is in the
                            # cigar string, 'M' can mean match or mismatch.
                            score = self._convertCigarMD(cig, MD=MD)
                    else:
                        score = self._convertCigarMD(cig)

                # Find index where match begins in read from cigar string
                # If cigar begins with S, H or H then S: index is after these.
                if cigarSplit[1] is 'S':
                    beginS = cigarSplit[0]
                elif cigarSplit[1] is 'H':
                    if cigarSplit[3] is 'S':
                        beginS = cigarSplit[0] + cigarSplit[2]
                    else:
                        beginS = cigarSplit[0]
                else:
                    beginS = 0

                # Find index from the end where match ends in read using
                # cigar string. Then can find index where match ends in
                # read using readEnd = len(seq) - 1 - lastS
                # If cigar end with S, H or S then H: index is before these.
                if cigarSplit[-1] is 'S':
                    lastS = cigarSplit[-2]
                elif cigarSplit[-1] is 'H':
                    if cigarSplit[-3] is 'S':
                        lastS = cigarSplit[-2] + cigarSplit[-4]
                    else:
                        lastS = cigarSplit[-2]
                else:
                    lastS = 0

                readStart = 0 + beginS
                readEnd = len(seq) - 1 - lastS
                subjStart = pos - 1
                subjEnd = (pos - 2 + len(seq) - cig['I'] - cig['S']
                           - cig['P'] + cig['N'] + cig['D'])

                # TODO use explain_sam_flags to determine frame
                # Does that now mean changing readStart etc?
                frame = [1, 1]
                if 'read reverse strand' in explain_sam_flags(flag):
                    frame[0] = -1

                hsp = HSP(score, readStart=readStart, readEnd=readEnd,
                          subjectStart=subjStart, subjectEnd=subjEnd)
                return hsp

    def readAlignments(self, reads):
        """
        Read lines of SAM file from self._filename, convert them to read
        alignments and yield them.

        @param reads: A generator yielding L{Read} instances, corresponding to
            the reads that were given to the aligner.
        @raise ValueError: If any of the lines in the file cannot be parsed.
        @return: A generator that yields C{dark.alignments.ReadAlignments}
            instances.
        """
        self._open(self._filename)  # Function to open the file.
        readIds = self._autovivify(2, list)
        for line in self._fp:
            if line[0] not in '$@':
                details = line.strip().split()  # Gives list of strings
                query = details[0]
                refSeqName = details[2]
                if refSeqName != '*':
                    subjTempLen = self._appParams[refSeqName]
                    alignment = Alignment(subjTempLen, refSeqName)
                    # Using autovivification ensures HSPs can be added to
                    # alignments.
                    readIds[query][alignment].append(self._lineToHSP(line))

        for read in reads:
            try:
                alignments = readIds[read.id]
            except KeyError:
                raise ValueError(
                    'Read id %s found in passed reads but not in SAM file %r '
                    % (read.id, self._fp))
            else:
                yield ReadAlignments(read, alignments)

        self._fp.close()
